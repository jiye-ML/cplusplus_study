十四 构造函数和初始化列表
1 构造函数可以重载、也可以带有缺省参数
2 缺省(无参)构造函数
1）如果类中没有定义任何构造函数，那么编译器会为该类提供一个缺省的构造函数(无参构造函数)
--》对于基本类型的成员变量不做初始化
--》对于类 类型的成员变量(成员子对象)，将会自动调用相应类的无参构造函数来初始化。
	eg:
	class XX{
		int m_i;//基本类型
		string m_s;//类类型的成员变量
	};
	XX x;
	cout << x.m_i << endl;//未知结果
	cout << x.m_s << endl;//一定是空字符串
2）如果自己定义了构造函数，无论是否有参数，编译器都不会在提供缺省的构造函数了.	

3 类型转换构造函数(单参构造函数)
  class 类名{
  		[explicit] 类名(源类型){...}
  };
  可以实现从源类型到当前类类型的隐式转换。
  注：可以使用explicit关键字修饰该构造函数，强制要求通过它实现的类型转换功能必须显式的完成。

4 拷贝(复制)构造函数
1）用一个已存在的对象构造同类型的副本对象，会调用该类的拷贝构造函数.
	class 类名{
		类名(const 类名& ){...}
	};
2）如果类中自己没有定义拷贝构造函数，那么编译器会为该类提供一个缺省的拷贝构造函数：
--》对于基本类型的成员变量，按字节复制
--》对于类类型的成员变量(成员子对象)，将自动调用相应类拷贝构造函数来初始化。

注：一般不需要自己写拷贝构造函数，因为编译器缺省提供的已经很好用了.

3）拷贝构造函数调用时机
--》用已定义的对象作为同类型对象的构造实参
--》以对象形式向函数传递参数
--》从函数中返回对象

5 初始化列表
1）语法
   class 类名{
   	类名(形参表):成员变量(初值),...{...}
   };
2）多数情况下，使用初始化列表和在构造函数体中对成员变量进程初始化操作，并没有太大区分，两种形式可以任选，但是有些特殊的场景必须要使用初始化列表：

//需要显式使用初始化列表的场景
3）如果有类类型的成员变量(成员子对象)，而该类又没有无参构造，则必须使用初始化列表来完成该成员子对象的初始化操作。
4）如果类中有"const"或“引用”成员变量，必须要使用初始化列表来完成其初始化操作。
5）成员变量的初始化顺序由声明顺序决定，和初始化列表的顺序无关，所以不要使用一个成员变量去初始化另一个成员变量.
