二十一 继承(Inheritance)
1 继承概念//了解
  	通过一种机制表达类型之间共性和特性的方式，利用已有的数据类型定义的新的数据类型，这种机制就是继承。
	eg:
		人类：姓名、年龄、吃饭、睡觉
		学生类：姓名、年龄、吃饭、睡觉、学号、学习
		教师类：姓名、年龄、吃饭、睡觉、工资、讲课
		...	
		---------------------
		//利用继承机制：
		人类：姓名、年龄、吃饭、睡觉
		学生类继承人类：学号、学习
		教师类继承人类：工资、讲课
		...	
		人类(基类、父类)
	  /    \
 学生类	教师类(子类、派生类)  
 
 基类(父类)--派生--》子类(派生类)
 子类(派生类)--继承--》基类(父类)

2 继承的语法
	class 子类:继承方式 基类1,继承方式 基类2,...{
		...
	};
	继承方式:
	1)public:公有继承
	2)protected:保护继承
	3)private:私有继承

3 公有继承的特性
1）子类对象会继承基类的属性和行为，通过子类对象可以直接访问基类中的成员，如同是基类对象在访问它们一样.
 注：子类对象中包含基类的部分称为“基类子对象”

2）向上造型(upcast)//重点掌握
  将子类类型的指针或引用转换为基类类型的指针或引用,这种操作性缩小类型转换在编译器看来是安全的，可以直接隐式转换.
	基类
	 ↑
	子类
	eg:
	class A{};
	class B:public A{};
	class C:public A{};
	void func(A* pa){}
	int main(void){
		B b;
		func(&b);//向上造型
		C c;
		func(&c);//向上造型
	}
3）向下造型(donwcast)
  将基类类型的指针或引用转换为子类类型的指针或引用.这种操作性放大的类型转换在编译器看来是危险的，不能隐式转换，但是可以显式转换.
	基类
	 ↓
	子类

4）子类继承基类的成员
--》在子类中，可以直接访问基类中的公有和保护成员，就如同它们是子类自己的成员一样.
--》基类中的私有成员子类也可以继承，但是会受到访问控制属性的限制，不能直接使用；如果希望让子类访问基类中的私有成员，可以由基类提供公有或保护的接口函数来间接访问.

5）子类隐藏基类的成员
   如果子类和基类定了同名的成员函数，因为作用域不同，不会构成函数重载关系，而是一种隐藏关系，通过子类对象将优先访问子类自己的成员。
   如果这时还希望访问到基类中被隐藏的同名成员，可以显式的通过“类名::”来指明.
   
4 继承方式和访问控制属性
1）访问控制属性：影响访问该类成员的位置
访问控制		访问控制		内部	子类	外部	友元
限定符		属性			访问	访问	访问	访问
public		公有成员		ok		ok		ok		ok
protected	保护成员		ok		ok		no		ok
private		私有成员		ok		no		no		ok
2）继承方式：影响通过子类访问基类中成员的可访问性
基类中的		在公有子		在保护子		在私有子
				类中变成		类中变成		类中变成
公有成员		公有成员		保护成员		私有成员
保护成员		保护成员		保护成员		私有成员
私有成员		私有成员		私有成员		私有成员
注：向上造型的语法特性在保护继承和私有继承中不再适用

5 子类的构造函数//参考06inherit.cpp
1）如果子类的构造函数没有指明基类子对象的初始化方式，那么编译器将自动调用基类的无参构造函数来初始化基类子对象.
2）如果希望基类子对象以有参的方式被初始化，则必须要使用初始化列表来显式指明.
3）子类对象的创建过程：
--》分配内存
--》构造基类子对象(按继承表顺序)
--》构造成员子对象(按声明顺序)
--》执行子类构造函数代码

6 子类析构函数
1）子类的析构函数，无论是自己定义的还是编译器缺省的，都会自动调用基类的析构函数
2）子类对象的销毁过程：
--》执行子类的析构函数代码
--》析构成员子对象(按声明逆序)
--》析构基类子对象(按继承表逆序)
--》释放内存
3）基类的析构函数不能自动调用子类的析构函数，所以对一个指向子类对象的基类指针，使用delete操作符，实际被执行的仅是基类的析构函数，子类的析构函数执行不到，有内存泄漏的风险.
   class A{};
   class B:public A{};
   A* pa = new B;//pa指向子类对象的基类指针
   delete pa;//有内存泄漏的风险
   
   解决方法：虚析构函数(后面)

7 子类的拷贝构造和拷贝赋值
1）拷贝构造函数
--》如果子类没有定义拷贝构造函数，编译器会为子类提供缺省拷贝构造函数，该函数会自动调用基类的拷贝构造函数，完成基类子对象的拷贝初始化。
--》如果子类自己定义了拷贝构造函数，需要显式的使用初始化列表指明基类子对象也以拷贝方式进行初始化.
	class Base{};
	class Derived:public Base{
		//Base(that):指明基类子对象以拷贝方式初始化
		Derived(const Derived& that):Base(that),...{}
	};
2）拷贝赋值操作符函数
--》如果子类自己没有定义拷贝赋值函数，编译器会为子类提供缺省的拷贝拷贝赋值函数，该函数会自动调用基类的拷贝赋值函数，完成基类子对象的复制。
--》如果子类自己定义了拷贝赋值函数，这时需要显式的调用基类的拷贝赋值函数，完成基类子对象的复制。
   class Base{};
	class Derived:public Base{
		Derived& operator=(const Derived& that){
			...
			//显式的调用基类的拷贝赋值函数
			Base::operator=(that);
		}
	};
