二十一 继承(Inheritance)
1 继承概念//了解
  	通过一种机制表达类型之间共性和特性的方式，利用已有的数据类型定义的新的数据类型，这种机制就是继承。
	eg:
		人类：姓名、年龄、吃饭、睡觉
		学生类：姓名、年龄、吃饭、睡觉、学号、学习
		教师类：姓名、年龄、吃饭、睡觉、工资、讲课
		...	
		---------------------
		//利用继承机制：
		人类：姓名、年龄、吃饭、睡觉
		学生类继承人类：学号、学习
		教师类继承人类：工资、讲课
		...	
		人类(基类、父类)
	  /    \
 学生类	教师类(子类、派生类)  
 
 基类(父类)--派生--》子类(派生类)
 子类(派生类)--继承--》基类(父类)

2 继承的语法
	class 子类:继承方式 基类1,继承方式 基类2,...{
		...
	};
	继承方式:
	1)public:公有继承
	2)protected:保护继承
	3)private:私有继承

3 公有继承的特性
1）子类对象会继承基类的属性和行为，通过子类对象可以直接访问基类中的成员，如同是基类对象在访问它们一样.
 注：子类对象中包含基类的部分称为“基类子对象”

2）向上造型(upcast)//重点掌握
  将子类类型的指针或引用转换为基类类型的指针或引用,这种操作性缩小类型转换在编译器看来是安全的，可以直接隐式转换.
	基类
	 ↑
	子类
	eg:
	class A{};
	class B:public A{};
	class C:public A{};
	void func(A* pa){}
	int main(void){
		B b;
		func(&b);//向上造型
		C c;
		func(&c);//向上造型
	}
3）向下造型(donwcast)
  将基类类型的指针或引用转换为子类类型的指针或引用.这种操作性放大的类型转换在编译器看来是危险的，不能隐式转换，但是可以显式转换.
	基类
	 ↓
	子类

4）子类继承基类的成员
--》在子类中，可以直接访问基类中的公有和保护成员，就如同它们是子类自己的成员一样.
--》基类中的私有成员子类也可以继承，但是会受到访问控制属性的限制，不能直接使用；如果希望让子类访问基类中的私有成员，可以由基类提供公有或保护的接口函数来间接访问.

5）子类隐藏基类的成员
   如果子类和基类定了同名的成员函数，因为作用域不同，不会构成函数重载关系，而是一种隐藏关系，通过子类对象将优先访问子类自己的成员。
   如果这时还希望访问到基类中被隐藏的同名成员，可以显式的通过“类名::”来指明.
   
4 继承方式和访问控制属性
1）访问控制属性：影响访问该类成员的位置
访问控制		访问控制		内部	子类	外部	友元
限定符		属性			访问	访问	访问	访问
public		公有成员		ok		ok		ok		ok
protected	保护成员		ok		ok		no		ok
private		私有成员		ok		no		no		ok
2）继承方式：影响通过子类访问基类中成员的可访问性
基类中的		在公有子		在保护子		在私有子
				类中变成		类中变成		类中变成
公有成员		公有成员		保护成员		私有成员
保护成员		保护成员		保护成员		私有成员
私有成员		私有成员		私有成员		私有成员
注：向上造型的语法特性在保护继承和私有继承中不再适用

5 子类的构造函数//参考06inherit.cpp
1）如果子类的构造函数没有指明基类子对象的初始化方式，那么编译器将自动调用基类的无参构造函数来初始化基类子对象.
2）如果希望基类子对象以有参的方式被初始化，则必须要使用初始化列表来显式指明.
3）子类对象的创建过程：
--》分配内存
--》构造基类子对象(按继承表顺序)
--》构造成员子对象(按声明顺序)
--》执行子类构造函数代码

6 子类析构函数
1）子类的析构函数，无论是自己定义的还是编译器缺省的，都会自动调用基类的析构函数
2）子类对象的销毁过程：
--》执行子类的析构函数代码
--》析构成员子对象(按声明逆序)
--》析构基类子对象(按继承表逆序)
--》释放内存
3）基类的析构函数不能自动调用子类的析构函数，所以对一个指向子类对象的基类指针，使用delete操作符，实际被执行的仅是基类的析构函数，子类的析构函数执行不到，有内存泄漏的风险.
   class A{};
   class B:public A{};
   A* pa = new B;//pa指向子类对象的基类指针
   delete pa;//有内存泄漏的风险
   
   解决方法：虚析构函数(后面)

7 子类的拷贝构造和拷贝赋值
1）拷贝构造函数
--》如果子类没有定义拷贝构造函数，编译器会为子类提供缺省拷贝构造函数，该函数会自动调用基类的拷贝构造函数，完成基类子对象的拷贝初始化。
--》如果子类自己定义了拷贝构造函数，需要显式的使用初始化列表指明基类子对象也以拷贝方式进行初始化.
	class Base{};
	class Derived:public Base{
		//Base(that):指明基类子对象以拷贝方式初始化
		Derived(const Derived& that):Base(that),...{}
	};
2）拷贝赋值操作符函数
--》如果子类自己没有定义拷贝赋值函数，编译器会为子类提供缺省的拷贝拷贝赋值函数，该函数会自动调用基类的拷贝赋值函数，完成基类子对象的复制。
--》如果子类自己定义了拷贝赋值函数，这时需要显式的调用基类的拷贝赋值函数，完成基类子对象的复制。
   class Base{};
	class Derived:public Base{
		Derived& operator=(const Derived& that){
			...
			//显式的调用基类的拷贝赋值函数
			Base::operator=(that);
		}
	};

8 多重继承
1）概念：一个子类同时继承多个基类，这样的继承方式被称为多重继承.	
	技术员	经理
		\     /
	   技术主管
	   
	电话	播放器	计算机
		\     |		/
	      智能手机
2）在向上造型时，编译器会根据各个基类子对象内存布局进行适当的偏移计算，保证指针的类型和所指向的目标基类子对象类型一致.//参考mul_inherit.png

3）名字冲突问题
--》一个子类的多个基类如果存在同名的成员，当通过子类访问这些名字时，编译器会报歧义错误--名字冲突。
--》解决名字冲突的通用做法，就是显式使用"类名::"，指明所访问的成员属于哪个基类//推荐
--》如果冲突的名字是成员函数，并满足不同参的重载条件，也可以通过using声明，让它们在子类中形成重载，通过重载的参数解析来解决//不推荐

9 多重继承(钻石继承)
1）一个子类的多个基类源自共同的基类祖先，这样的继承结构称为钻石继承.
		 A
		/ \
	  B	C
	   \ /
	    D 
	  A：称为公共基类
	  B、C：称为中间类
	  D：末端子类
2）钻石继承的问题：
	在创建末端子类对象时，公共基类(A)子对象会存在多份实例，这时通过末端子类对象访问公共基类的成员，会因为继承路径不同而导致结果不一致。
	
3）通过虚继承，可以让公共基类子对象实例唯一，并为所有的中间类共享，这样即使沿着不同的继承路径，所访问到公共基类的成员一定是一致的。

4）虚继承语法
--》在继承表使用virtual关键字修饰
--》位于继承链最末端子类负责构造公共基类子对象
		 A
		/ \
	  B	C//:virtual public A
	   \ /
	    D//负责构造公共基类(A)子对象 