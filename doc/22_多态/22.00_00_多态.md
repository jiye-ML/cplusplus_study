二十二 多态(Polymorphic)
eg:实现图形库
				 图形(位置/绘制)
				/				\
	圆形(半径/绘制)		矩形(宽和高/绘制) ...

1 函数重写(虚函数覆盖)、多态的概念
  如果将基类中某个成员函数声明为虚函数，那么其子类中具有相同原型的成员函数就也是虚函数，并且会对基类中的版本形成虚函数的覆盖，也称为函数重写.
  这时，通过指向子类对象的基类指针，或引用子类对象的基类引用，调用虚函数，实际被执行的将是子类中的覆盖版本，而不再是基类中原始版本，这种语法现象被称为多态.
  class A{
  		virtual void func(void){...}
  };
  class B:public A{
  		void func(void){...}//也是虚函数
  };
  int main(void){
  		B b;
  		A* pa = &b;//pa:指向子类对象的基类指针
  		A& ra = b;//ra:引用子类对象的基类引用
  		pa->func();//被执行的将是子类中的覆盖版本
  		ra.func();//被执行的将是子类中的覆盖版本
  }
  
2 函数重写语法要求(虚函数覆盖条件)
1）只有类中成员函数才能声明虚函数，而全局函数、静态成员函数、构造函数不能被声明为虚函数
	注：析构函数可以虚(特殊后面讲)
2）只有基类中以virtual声明的虚函数才能被子类版本覆盖，而与子类中的virtual关键字无关。
3）虚函数在子类的覆盖版本和基类中原始版本，函数签名必须一致：即函数名、形参表、常属性一致
4）如果基类中的虚函数返回基本类型的数据，那么子类中的覆盖版本必须返回相同类型的数据.
5）如果基类中的虚函数返回类类型的指针(A*)或引用(A&)，那么有允许子类中覆盖版本返回其子类类型的指针(B*)或引用(B&)
	class A{};
	class B:public A{};

3 多态条件
1）多态的语法特性除了要满足函数重写的要求，还必须是通过指针或引用调用虚函数才能表现出来.
2）调用虚函数的指针也可以this指针，当通过子类对象调用基类中的成员函数，这时this将是一个指向子类对象的基类指针，再通过this调用虚函数，同样可以表现多态语法特性.//重点掌握

eg:Qt多线程
	class QThread{//Qt官方写好的表示多线的类
	protected:
		virtual void run(void){
			//线程入口函数
		}
	public:
		void start(void){
			this->run();	
		}
	};
	class MyThread:public QThread{
	protected:
		virtual void run(void){
			//线程入口函数
		}
	};
	MyThread thread;
	thread.start();

4 多态原理(虚函数表和动态绑定)//了解,参考poly.png
1）虚函数表会增加内存开销
2）动态绑定过程增加时间开销
3）虚函数不能做内联优化
结论：实际开发中如果没有多态的语法要求，最好不要使用虚函数。

5 纯虚函数、抽象类和纯抽象类
1）纯虚函数
	virtual 返回类型 函数名(形参表) = 0;
2）抽象类
	如果类中包含了纯虚函数，那么该类就是抽象类。
	注：抽象类不能创建对象，如果子类没有覆盖基类中的全部纯虚函数，那么该子类就也是抽象类，类的抽象属性可以被继承.
3）纯抽象类（有名接口类）
	如果一个抽象类所有的成员函数都为虚函数，那么该抽象类就是纯抽象类.
	
6 虚析构函数
1）基类的析构函数不能自动调用子类的析构函数，所以对一个指向子类对象的基类指针，使用delete操作符，实际被执行的仅是基类的析构函数，子类的析构函数执行不到，有内存泄漏的风险.

//解决方法：虚析构函数
2）可以将基类的析构函数声明为虚函数，这时子类的析构函数就也是虚函数，并可以对基类中的虚析构函数形成有效的覆盖，也可以表现多态的语法特性；这时再delete一个指向子类对象的基类指针，实际被执行的将是子类的析构函数，子类析构函数执行结束以后会自动调用基类的析构函数，避免了内存泄漏.
